integer /[0-9]+/ text
number /[0-9]+(\.[0-9]*)([eE][\+\-]?[0-9]+)?/ text
id /[a-z_][a-z_0-9]*/ text
lparen /\(/
rparen /\)/
comma /,/
add /\+/
sub /\-/
mul /\*/
div /\//
pow /\^/
assign /=/
def /def/
/ +/
int_t /int/
float_t /float/

%%

%top {
#include "parserBase.h"
}

%inherit{: public ParserBase}

S ->
    E       { std::move(_1) }
  | FuncDef { std::move(_1) }
  ;

FuncDef ->
  def id lparen DefArgs rparen assign E { std::make_shared<FunctionDef>(_2.text, _4, _7) }
  ;

DefArgs ->
    DefArgsOne  { std::move(_1) }
  |             { std::make_shared<DefArgs>() }
  ;

DefArgsOne ->
    DefArgsOne comma Type id { std::make_shared<DefArgs>(_1, _3, _4.text) }
  | Type id                  { std::make_shared<DefArgs>(_1, _2.text) }
  ;

Type ->
    int_t   { std::make_shared<TypeNode>(Type::IntType) }
  | float_t { std::make_shared<TypeNode>(Type::FloatType) }
  ;

E ->
    %left1  E add E       { makeExpr(OpType::Add, _1, _3) }
  | %left1  E sub E       { makeExpr(OpType::Sub, _1, _3) }
  | %left2  E mul E       { makeExpr(OpType::Mul, _1, _3) }
  | %left2  E div E       { makeExpr(OpType::Div, _1, _3) }
  | %right4 E pow E       { makeExpr(OpType::Exp, _1, _3) }
  | lparen E rparen       { std::move(_2) }
  | id                    { makeExpr(_1.text) }
  | number                { makeExpr(std::stod(_1.text)) }
  | integer               { makeIntExpr(std::stoi(_1.text)) }
  | %left3 sub E          { makeExpr(_2) }
  | %right0 id assign E   { makeExpr(_1.text, std::move(_3)) }
  | id lparen Args rparen { makeFunCall(_1.text, std::move(_3)) }
  ;

Args ->
    ArgsOne               { std::move(_1) }
  |                       { std::make_shared<Arguments>() }
  ;

ArgsOne ->
    ArgsOne comma E       { std::make_shared<Arguments>(_1, _3) }
  | E                     { std::make_shared<Arguments>(_1) }
  ;
